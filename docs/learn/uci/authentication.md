---
sidebar_position: 3
---

# Authentication

## Digital Signatures and Authentication

To prevent spamming, false identity and data tampering, Topos XSP leverages _digital signatures_ to ensure Certificates are attributed to the right originators—i.e. the blockchains that emit them to prove the validity of their state transitions—and that their integrity is retained during their propagation. As seen previously, signatures are included in Certificates and hence can be validated prior to verifying the Certificate validity using a public key assigned to their origin subnet.

A basic digital signature allows an _individual_ entity to sign a message. However, in blockchain environments we tend to distribute trust among the group of validators rather than a single entity. That's why multi-signatures and threshold signatures are used by different blockchain projects. While multi signatures give the signing authority to a predefined group of entities, in threshold signatures _any_ group of signers of sufficiently large cardinality are able to sign valid messages.

Authentication is achieved in Toposware ecosystem via a [Threshold Signature Scheme](https://link.springer.com/chapter/10.1007/3-540-45539-6_15).



## Threshold Signatures: ICE-FROST

To allow a non-unary and dynamic set of signers to sign Certificates against a static public key, Topos XSP makes use of **ICE-FROST**, an in-house customization of the [FROST](https://eprint.iacr.org/2020/852.pdf) threshold signature scheme.

:::tip Threshold Signature

A _t out of n_ threshold signature scheme is a multi-party digital signature protocol such that any honest subset of signers of cardinality _t_ or greater of the total of _n_ participants is sufficient to successfully create a valid signature.

:::

The customizations augment FROST with robustness in the distributed key generation phase. The robustness of ICE-FROST is achieved via exact **identification of a cheating entity** during the key generation. The protocol also has two additional important properties that are tailored for our XSP design, namely:

i) exact **identification of a cheating entity** during the signing protocols, that can conclude in preventing cheating if suitable punishments are predicted for cheaters, and

ii) allows a blockchain network to distribute a **static long-running verification key** with respect to which signatures can be produced by different sets of signers.

This allows the verification key associated to each subnet to stay static while the set of potential signers can vary easily. This is a key feature for blockchains, i.e. dynamic networks whose participating nodes arbitrarily join and leave.



### ICE-FROST in XSP

ICE-FROST is used in XSP for signing certificates by the subnet validators. The main purpose of signing is authenticating the subnet creating the certificate and verifying the integrity of the certificate, i.e. ensuring that the certificate was not altered while in transit. The number of validators required to generate a valid signature with ICE-FROST can be freely chosen by the subnet. A malicious party would then need to control more than this threshold to sign a false certificate committing to a malicious state that honest validators disagree with. Since it is assumed that subnets are running a BFT consensus mechanism, and that at most one third of all participants are malicious, the XSP heavily recommends a threshold greater than one third of the total number of validators. A greater threshold means increased security at the cost of availability: if there isn't enough honest validators to reach the threshold, then the subnet might be unable to sign a certificate.

When a subnet registration takes place, the initial set of validators runs the initial DKG phase, as a result of which they obtain a static ICE-FROST verification key that is required to verify certificate signatures. This verification key is included in the registration and stays static for the lifetime of the given subnet. The set of validators is updated every *epoch* (e.g., approximately every six hours in our case). This is when an update of the shares phase takes place. Since the verification key is designed to be static, the redistribution of shares does not change the group signing and verification keys. Note that both the initial and redistribution phases are *dealerless*.

The certificates are signed and then propagated with the signature by the [TCE nodes](/learn/tce/tce-nodes) the subnet is connected to. When it reaches the other TCE nodes, the signature is verified using the subnet's verification key. The signature is of the same format as a regular Schnorr signature (even though it is generated by a group of signers instead of individual ones). Checking the certificate signature before processing the certificate is very fast and effectively prevents spamming if an adversary sends multiple certificates with invalid signatures.




### ICE-FROST Protocol Outline

In this section, we will provide an outline of ICE-FROST.

#### Preliminaries

##### Schnorr Signature Algorithm

[Schnorr signature algorithm](https://link.springer.com/article/10.1007/BF00196725) is a digital signature algorithm. FROST and ICE-FROST are both based on Schnorr, hence we will briefly describe it here.

Schnorr signatures are constructed based on the Sigma protocol structure. Sigma protocols consist of three message transmissions between a prover and a verifier; i) the prover sends a commitment value to the verifier, ii) the prover sends a uniformly random challenge to the verifier, and iii) the prover answers to the challenge using some public function, and a witness. The prover is the signer in the Schnorr signature scheme and the witness is the secret key held by the signer that is kept secret using the discrete log hardness assumption. The signature scheme is made and used non-interactively using [Fiat-Shamir transform](https://link.springer.com/content/pdf/10.1007/3-540-47721-7_12.pdf) that is practically using the output (digest) of a hash function with input of the commitment, witness and the message instead of the challenge value.

#### Distributed Key Generation (DKG): Initial Run

ICE-FROST distributed key generation protocol is based on the [DKG algorithm of Pedersen](https://link.springer.com/chapter/10.1007/3-540-46416-6_47), which is a distributed secret sharing scheme, combined with [Shamir's Secret Sharing](https://dl.acm.org/doi/abs/10.1145/359168.359176). All participants of the DKG algorithm _securely_ distribute their random chosen secrets among other participants. Since no participant is trusted prior to execution of the protocol, a _verifiable_ secret sharing scheme is used that allows participants to verify if the received share is consistent with others. Verifiability is achieved by enforcing each participant to commit to its chosen secret (and the corresponding polynomial that is used for secret sharing) and broadcast the commitment values at the beginning of the protocol. After successful sharing of secrets, participants interpolate their received shares to compute their private signing share. The group's public verification key is calculated using the public broadcasted commitments.

To enable cheating identifiability in ICE FROST, each participant chooses a pair of ephemeral public and private keys for each secret dealing and publishes the public key and a proof of knowledge of the corresponding private key. In order to securely send shares to each participant a [Diffie-Hellman(DH) key agreement](https://ee.stanford.edu/%7Ehellman/publications/24.pdf) is used to established shared secret key between the sender and receiver of the given share. This key is used to securely encrypt the share and send it out to the corresponding receiver. If a participant cheats by sending out an inconsistent share, the receiver will catch it using the initial published commitment. However, since shares are transmitted in the encrypted form, the receiver of the malformed share has to reveal the mutually established DH key, as well as a proof of its correctness, to convince other participants that it has received a malformed share. If the receiver lies and accuses an honest participant of sending a malformed share it will be caught itself after other participants check its complaint using the revealed DH key.

#### Updating Shares

Participants' shares are updated by running the _key update protocol_ which is a redistribution of secret shares to provide each shareholder with a fresh signing share while allowing new participants to join or the old ones to leave the protocol. Even if the set of participants stay the same, it is recommended to run the key update protocol every once in a while (e.g., every six hours) to maintain the security of distributed keys. To redistribute the secret key, each participant distributes its secret signing share using the described DKG. If required, the set of participants and the scheme's parameters (the threshold and the total number of participants) can be updated during each run of the key update protocol.

#### Preprocessing

As mentioned above, in a Schnorr signature scheme, the signer initially generates a commitment to a random nonce and sends it to the verifier. In a threshold Schnorr signature scheme, the nonce generation (as well as the private/public key generation) should be made distributed such that any set of at least _t_ participants can generate a valid nonce and corresponding commitment. The distributed nonce can be generated by running a separate round of DKG algorithm. However, in order to avoid adding an extra round to the protocol and achieve a round-optimized protocol, nonce and its commitment can be generated during a preprocessing round. During the preprocessing round, each participant generates a list of single-use private nonce pairs and corresponding public commitment shares. Each entry of the list will be used for signing one message and once all are used, the preprocessing round will re-run.

#### Signing

A group of signers with at least *t* members is randomly selected to generate the *(t,n)*-threshold signature. However, generation of a valid signature requires cooperation of at least *t* **honest** participants. A larger set of signers (or even all participants) can be chosen to ensure at least *t* honest participants are among the chosen ones with high probability, at the cost of more communication between participants and a heavier protocol.

After the random set of signers is selected, they will fetch each other's commitments that have been published and stored during the preprocessing round. Each participant checks the validity of the obtained values and calculates a _binding value_ to the message and the group of signers. Then, each one of them derives another commitment value that binds the message, the set of signing participants, and each participant’s commitment to each signature share. This latter commitment will be used to calculate the group's commitment value. The challenge value of the Schnorr's signature will then be generated by applying a hash function on the group's commitment value, public key and the message. Each participant responds to the challenge, using its committed nonces (from preprocessing), and their signing key share. Every participant then checks the validity of responses and, if they all passed, adds all the responses to generate the group's threshold signature. All honest participants will end up with the same valid signature. Note that if any of the checks during signing fails, the signing phase will have to be rerun from the beginning, excluding the set of discovered malicious signers.



### Benefits of ICE-FROST over FROST

The main benefits of ICE-FROST over its predecessor FROST are:

- Robustness of key generation phase, meaning that we are guaranteed to obtain a verification key and/or redistribute the shares, without aborting the protocol.
- Provable identifiability of cheating entities, who are either sending malformed shares or making false accusations.
- Redistribution feature of shares, which allows the group public key to be static, meaning that it could be used for as long as required by the group or in our specific case by the subnet.



### Future Work and Next Steps

ICE-FROST, as previously mentioned has a robust distributed key generation phase. The next step is to make the signing phase robust as well. At the moment, it is semi-robust, due to the fact that it will need to be re-run if at least one of the signers is malicious. Given that the malicious participants are excluded in the next run and re-runs, the signature is still generated. Thus, a logical next step is to make signing run only once per certificate. This will most likely come at a cost. Thus, we see this next step as an additional option, rather than a replacement of the current one.

Notice that having both options available would not cause any interoperability issues, as the final signature in any case will be a Schnorr signature with respect to the given group public key and hence can still be verified by any entity with ability to verify Schnorr signatures.
