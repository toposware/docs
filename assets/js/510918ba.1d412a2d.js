"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[326],{3905:function(e,t,n){n.d(t,{Zo:function(){return f},kt:function(){return d}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},f=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,f=c(e,["components","mdxType","originalType","parentName"]),u=l(n),d=i,h=u["".concat(s,".").concat(d)]||u[d]||p[d]||a;return n?r.createElement(h,o(o({ref:t},f),{},{components:n})):r.createElement(h,o({ref:t},f))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,o[1]=c;for(var l=2;l<a;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},915:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return f},default:function(){return u}});var r=n(3117),i=n(102),a=(n(7294),n(3905)),o=["components"],c={sidebar_position:2},s="Conflicting Certificates",l={unversionedId:"learn/tce/conflicting-certificates",id:"learn/tce/conflicting-certificates",title:"Conflicting Certificates",description:"In the event that a subnet has been taken over by an adversary, honest subnet participants\u2019 funds cannot be stolen since signatures cannot be forged by the adversary. On the other hand, if the adversary controls enough of the ICE-FROST participants, it can sign two certificates which conflict with each other. In this situation, equivocating allows the adversary to send the same funds twice, once in each of the certificates.",source:"@site/docs/learn/tce/conflicting-certificates.md",sourceDirName:"learn/tce",slug:"/learn/tce/conflicting-certificates",permalink:"/learn/tce/conflicting-certificates",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/learn/tce/overview"},next:{title:"Topos Reliable Broadcast",permalink:"/learn/tce/trb"}},f=[],p={toc:f};function u(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"conflicting-certificates"},"Conflicting Certificates"),(0,a.kt)("p",null,"In the event that a subnet has been taken over by an adversary, honest subnet participants\u2019 funds cannot be stolen since signatures cannot be forged by the adversary. On the other hand, if the adversary controls enough of the ICE-FROST participants, it can sign two certificates which conflict with each other. In this situation, equivocating allows the adversary to send the same funds twice, once in each of the certificates."),(0,a.kt)("p",null,"In Topos, outgoing certificates from a given subnet are totally ordered, states are sequential and build on top of one another. As such, all certificate zk-STARK proofs are linked, even across different certificates: for each zk-STARK proof, its input corresponds to the previous proof\u2019s output."),(0,a.kt)("p",null,"Two certificates ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,b")," are said to be conflicting if both are valid with respect to the previous certificate ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k-1")," but the operations associated with the two certificates do not have a legal sequential history. In other words, when taking the output state of ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,a")," (resp. ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,b"),") and passing it as input to ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,b"),"\u2019s (resp. ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,a"),") zk-STARK, the verification will fail."),(0,a.kt)("p",null,"Without a mechanism to prevent conflicting certificates, a compromised subnet would be able to double-spend and break consistency of the ecosystem."),(0,a.kt)("p",null,"In order to prevent such situations, the TCE implements a ",(0,a.kt)("a",{parentName:"p",href:"/learn/tce/trb"},"reliable broadcast primitive")," to ensure that two conflicting certificates cannot be delivered by the TCE."))}u.isMDXComponent=!0}}]);