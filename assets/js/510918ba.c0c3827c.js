"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[326],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),f=l(n),d=i,b=f["".concat(s,".").concat(d)]||f[d]||u[d]||a;return n?r.createElement(b,o(o({ref:t},p),{},{components:n})):r.createElement(b,o({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=f;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,o[1]=c;for(var l=2;l<a;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},915:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return p},default:function(){return f}});var r=n(3117),i=n(102),a=(n(7294),n(3905)),o=["components"],c={sidebar_position:2},s="Conflicting Certificates",l={unversionedId:"learn/tce/conflicting-certificates",id:"learn/tce/conflicting-certificates",title:"Conflicting Certificates",description:"Like any distributed systems/blockchain, the TCE is vulnerable to double-spending attacks.",source:"@site/docs/learn/tce/conflicting-certificates.md",sourceDirName:"learn/tce",slug:"/learn/tce/conflicting-certificates",permalink:"/learn/tce/conflicting-certificates",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/learn/tce/overview"},next:{title:"Topos Reliable Broadcast",permalink:"/learn/tce/trb"}},p=[],u={toc:p};function f(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"conflicting-certificates"},"Conflicting Certificates"),(0,a.kt)("p",null,"Like any distributed systems/blockchain, the TCE is vulnerable to double-spending attacks."),(0,a.kt)("p",null,"In the event that a subnet has been taken over by an adversary, honest subnet participants\u2019 funds cannot be stolen funds since signatures cannot be forged by the adversary. On the other hand, if the adversary controls enough of the ICE-FROST participants, it can sign two certificates which conflict with each other. Equivocating the adversary can then effectively send the same transaction twice, one in each of the certificates."),(0,a.kt)("p",null,"In Topos, certificates from a given subnet are totally ordered and states are sequential and build on top of one another, such that each zk-STARK proofs of certificates are linked, even across different certificates: for each zk-STARK proof, its input corresponds to the previous proof\u2019s output"),(0,a.kt)("p",null,"Two certificates ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,b")," are said to be conflicting if both are valid with respect to ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k-1")," but the operations associated with the two certificates do not have a legal sequential history. In other words, when taking the output state of ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,a")," (resp. ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,b"),") and passing it as input to ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,b"),"\u2019s (resp. ",(0,a.kt)("inlineCode",{parentName:"p"},"Cert_k,a"),") zk-STARK, the verification will fail."),(0,a.kt)("p",null,"Without a mechanism to prevent conflicting certificates, a compromised subnet would be able to double-spend and break consistency of the ecosystem."),(0,a.kt)("p",null,"In order to prevent such situations, the TCE implements a ",(0,a.kt)("a",{parentName:"p",href:"/learn/tce/trb"},"reliable broadcast primitive")," to ensure that two conflicting certificates cannot be delivered by the TCE."))}f.isMDXComponent=!0}}]);